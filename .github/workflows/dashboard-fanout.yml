---
name: Task Assistant • Dashboard • Fanout

# yamllint disable rule:truthy
on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 4 * * *"

permissions:
  contents: write
  id-token: write

jobs:
  fanout:
    runs-on: ubuntu-latest

    env:
      ENGINE_NAME: dashboard
      ENGINE_JOB: fanout

    steps:
      # ─────────────────────────────────────────────
      # Checkout Task Assistant (infra + scripts)
      # ─────────────────────────────────────────────
      - name: Checkout Task Assistant
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: |
          set -euo pipefail
          npm ci

      # ─────────────────────────────────────────────
      # Resolve host repo context (authoritative)
      # ─────────────────────────────────────────────
      - name: Resolve repo context
        run: |
          set -euo pipefail

          OWNER="${GITHUB_REPOSITORY%%/*}"
          REPO="${GITHUB_REPOSITORY##*/}"

          echo "OWNER=$OWNER" >> "$GITHUB_ENV"
          echo "REPO=$REPO" >> "$GITHUB_ENV"

      # ─────────────────────────────────────────────
      # Generate GitHub App token (infra access)
      # ─────────────────────────────────────────────
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.CODEX_APP_ID }}
          private-key: ${{ secrets.CODEX_PRIVATE_KEY }}

      # ─────────────────────────────────────────────
      # Generate correlation ID
      # ─────────────────────────────────────────────
      - name: Generate correlation ID
        run: |
          set -euo pipefail
          echo "CORRELATION_ID=${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}" >> "$GITHUB_ENV"

      # ─────────────────────────────────────────────
      # Resolve telemetry repo for host (once)
      # ─────────────────────────────────────────────
      - name: Resolve infra for fanout telemetry
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail

          cat > resolve-fanout-infra.mjs <<'JS'
          import fs from "fs";
          import { resolveInfraForRepo } from "./lib/infra.js";

          const result = await resolveInfraForRepo({
            targetRepo: process.env.GITHUB_REPOSITORY,
            githubToken: process.env.GITHUB_TOKEN
          });

          if (!result.telemetryRepo) {
            console.error("::error::Unable to resolve telemetry repo for fanout");
            process.exit(1);
          }

          fs.writeFileSync(
            "fanout-infra.json",
            JSON.stringify(result, null, 2)
          );
          JS

          node resolve-fanout-infra.mjs

          TELEMETRY_REPO="$(jq -r '.telemetryRepo' fanout-infra.json)"
          echo "TELEMETRY_REPO=$TELEMETRY_REPO" >> "$GITHUB_ENV"

      # ─────────────────────────────────────────────
      # Enumerate dashboard-eligible repos (v2 + v1)
      # ─────────────────────────────────────────────
      - name: Resolve dashboard fanout plan
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail

          cat > resolve-dashboard-fanout.mjs <<'JS'
          import fs from "fs";
          import { listDashboardEligibleRepos } from "./lib/infra.js";

          const plan = await listDashboardEligibleRepos({
            githubToken: process.env.GITHUB_TOKEN,
            allowV1Fallback: true
          });

          fs.writeFileSync(
            "fanout-plan.json",
            JSON.stringify(plan, null, 2)
          );

          console.log("Dashboard fanout plan:");
          console.log(JSON.stringify(plan, null, 2));
          JS

          node resolve-dashboard-fanout.mjs

      # ─────────────────────────────────────────────
      # Trigger dashboard builds (repo-scoped)
      # ─────────────────────────────────────────────
      - name: Trigger dashboard builds
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail

          COUNT="$(jq length fanout-plan.json)"

          if [[ "$COUNT" -eq 0 ]]; then
            echo "ℹ️ No dashboards to build"
            exit 0
          fi

          for row in $(jq -c '.[]' fanout-plan.json); do
            OWNER="$(echo "$row" | jq -r '.owner')"
            REPO="$(echo "$row" | jq -r '.repo')"
            TELEMETRY_REPO="$(echo "$row" | jq -r '.telemetryRepo')"

            echo "→ Triggering dashboard build for $OWNER/$REPO"

            gh workflow run engine-dashboard.yml \
              --repo "${GITHUB_REPOSITORY}" \
              -f owner="$OWNER" \
              -f repo="$REPO" \
              -f telemetry_repo="$TELEMETRY_REPO" \
              -f correlation_id="$CORRELATION_ID"
          done

      # ─────────────────────────────────────────────
      # Emit fanout telemetry (repo-scoped, safe)
      # ─────────────────────────────────────────────
      - name: Emit fanout telemetry
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        OWNER: automated-assistant-systems
        REPO: task-assistant
        TELEMETRY_REPO: automated-assistant-systems/task-assistant-telemetry
        working-directory: task-assistant
        run: |
          set -euo pipefail

          # Extract dashboards as opaque strings (NO owner/repo objects)
          DASHBOARDS="$(jq -r '
            [.[] | "\(.owner)/\(.repo)"]
            ' fanout-plan.json)"

          COUNT="$(jq 'length' <<<"$DASHBOARDS")"

          jq -n \
            --argjson dashboards "$DASHBOARDS" \
            --argjson count "$COUNT" \
            '{
              ok: true,
              engine: "dashboard-fanout",
              summary: "Dashboard fanout completed",
              dashboards_planned: $count,
              dashboards: $dashboards
            }' > result.json

          OWNER="$OWNER" \
          REPO="$REPO" \
          ENGINE_NAME="dashboard" \
          ENGINE_JOB="fanout" \
          RESULT_FILE="result.json" \
          ./scripts/telemetry/emit-engine.sh
